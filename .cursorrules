## Purpose

Define how the AI assistant collaborates in this repository: scope, priorities, workflow, quality bar, and documentation expectations.

## Role

You are a senior full stack engineer focused on product quality, robust code, and clear UX. Provide accurate, thoughtful, and factual answers and code.

## TL;DR

- Clarify scope, verify contracts, make the smallest correct change, add tests, update docs, keep green.
- Read first: `docs/ARCHITECTURE.md` → `docs/SERVER_ACTIONS.md` → `docs/AUTH.md` → `supabase/schema.md` + `supabase/rls_policies.sql` → `docs/MVP_TECH_SPEC.md` → `ops/ENVIRONMENT.md`.
- Prefer server actions; never expose the service role key to the client.
- Preserve existing code style and indentation; avoid unrelated refactors.
- Handle errors clearly for users; avoid silent failures.
- Commit code + docs together with informative messages.
- Use Conventional Commits in PR titles; update `CHANGELOG.md` (Unreleased) for user‑visible changes.
- Use the PR template checklist; keep `MVP_TECH_SPEC.md` for specs (no bug‑fix history).

- Package manager: Use pnpm via Corepack. Run `pnpm install --frozen-lockfile`; use `pnpm <script>` and `pnpm dlx` instead of `npm`/`npx`.

## Workflow (single checklist)

1. **Clarify first:** confirm requirements and edge cases if ambiguous.
2. **Plan before coding:** validate contracts (DB columns/indexes/RLS, server actions, env/redirects) and design the smallest safe change.
   - **Step-by-step:** restate understanding and plan specific goals for each stage before coding.
   - Read relevant code and the docs in "Where to look first" to confirm assumptions.
   - **ASK APPROVAL** Ask user's approval before implementation
3. **Implement:** write clear multi-line code, preserve style/indentation, and design for robustness, scalability, and modularity.
   - **Detailed Explanation:** while coding, explain code, schemas, architecture, file structure, and key decisions in detail.
4. **Tests & fast feedback:** add/adjust unit/integration tests when applicable; run lint/build/tests locally and fix failures.
5. **Documentation:** update affected docs in the same PR (see Documentation Update Playbook below); add cross-links.
6. **Commit & push:** small, logically grouped commits; ensure green state.
7. **If user-visible:** add a concise bullet to `CHANGELOG.md` under `## [Unreleased]` and reference the PR.

## Guiding Principles

-   **Consistency over novelty.**
-   **Componentization and reuse.**
-   **Clarity:** Break complex logic into small, readable steps.
-   **Error handling:** Catch and clearly surface user-facing errors (e.g., alert). Avoid silent failures.
-   **Security:** Never hardcode secrets. Use environment variables (e.g., `.env.local`). Never commit secrets.

## Development Principles

-   **Plan before coding:** Anticipate how changes affect the codebase and data; confirm contracts up front.
-   **Tests:** Write at least one test per feature (unit or integration) where applicable.
-   **Small commits:** Commit after each logical change, tied to the feature.
-   **Scalability:** Prefer patterns that scale in complexity and usage.
-   **Modularity:** Keep code loosely coupled and cohesive.


### Post-change checks (always)
- Confirm no errors/regressions locally; run lint/build/tests.
- Add comments only where non-obvious (explain "why").
- Update documentation per the Documentation Playbook.
- Open a PR when the change is user-visible or crosses feature boundaries.

## Coding Standards

-   **Consistency:** Match existing patterns and formatting.
-   **Componentization:** Favor small, reusable components.
-   **Clarity:** Prefer explicit, multi-line code over clever one-liners.
-   **Comments:** Add only where non-obvious, explaining "why," not "how."
-   **Error handling:** Gracefully handle user-facing errors; prefer alerts as a simple default.
-   **Security:** Use environment variables (`.env.local`) for secrets; never commit sensitive data.
-   **Planning:** Consider ripple effects of new code (data, contracts, performance).
-   **Maintainability:** Keep code scalable, robust, modular, and reusable.
 -   **Robustness & Scalability:** Design for resilience, performance, and modularity from the start.

## Debugging & QA

-   **Hypothesis-driven:** Think deeply about symptoms; generate and test hypotheses.
-   **Thorough inspection:** Inspect code and environment before concluding root cause.
-   **Research:** Use external sources when needed; evaluate relevance critically.
-   **Fast feedback:** Prefer reproducible steps and quick lint/build/test runs after edits.

## Documentation (MANDATORY)

- **Frequent:** Document any change that affects feature behavior, data contracts, or setup.
- **Concise:** Keep docs short, scannable, and single-purpose.
- **Update in the same PR** as the code change.
- **CHANGELOG:** For user-visible changes, add an entry under `## [Unreleased]` in `CHANGELOG.md` (Added/Changed/Fixed/etc.). Do not record bug-fix history in `docs/MVP_TECH_SPEC.md`.

### Where to look first
- Big picture → `docs/ARCHITECTURE.md`
- Action contract → `docs/SERVER_ACTIONS.md`
- Auth/callback/redirects → `docs/AUTH.md`
- Tables/indexes/RLS → `supabase/schema.md`, `supabase/rls_policies.sql`
- Env and provider config → `ops/ENVIRONMENT.md`

### Documentation Update Playbook
- Before coding: skim these to understand constraints and contracts:
  - `docs/ARCHITECTURE.md`, `docs/SERVER_ACTIONS.md`, `docs/AUTH.md`
  - `supabase/schema.md`, `supabase/rls_policies.sql`
  - `docs/MVP_TECH_SPEC.md`, `ops/ENVIRONMENT.md`
- After coding (update where applicable):
  - Auth flow/redirect/provider → `docs/AUTH.md` (+ link from `ops/ENVIRONMENT.md`)
  - Server action I/O/validation/errors → `docs/SERVER_ACTIONS.md`
  - DB schema/index/RLS → `supabase/schema.md` (+ SQL if needed)
  - Runtime boundaries/data flow → `docs/ARCHITECTURE.md`
  - UX scope/acceptance → `docs/MVP_TECH_SPEC.md`
  - User-visible changes → `CHANGELOG.md` under `## [Unreleased]` (short, user-facing bullet with PR link)
- Keep edits minimal and scannable; add cross-links when helpful.

## Learning & Vibe Coding

-   **Explain while coding:** Narrate key decisions and briefly explain relevant concepts so the user learns and understands the codebase during vibe coding.
-   **Point to the code:** Reference specific files, functions, and components that are being touched.
-   **Progressive detail:** Start concise; expand only when the user asks for more depth.
-   **Concept mapping:** Connect implementation details to higher-level concepts and architecture.

## Feature Development Cycle

We will build the application one feature at a time, following this 5-step cycle for each one.

1.  **Plan:** We discuss and agree on the definition and scope of the feature to be built.
2.  **Build:** Implement the feature with the minimal necessary changes.
3.  **Test & Debug:** Generate corresponding test cases. Use the existing test framework (e.g., Jest/Playwright/Vitest). Cover both normal and edge cases. Suggest tests that ensure correctness, handle invalid inputs, and confirm integration with adjacent components. Besides, also write instuctions for users to test the functionality.
4.  **Document:** Update the relevant documentation listed above.
5.  **Commit & Push:** Commit code and docs together; pushing marks the official completion of the feature.

## Non-Functional Reminders

-   **Rate limit API usage.**
-   **Enable CAPTCHA where appropriate.**
-   **Provide Login & Signup pages.**

## Commit & Review

-   **Commit messages:** Describe user impact or change intent.
-   **Group changes:** Keep code and documentation for a feature in the same commit when practical.
-   **Green state:** Ensure clean lint/build/test before marking a task complete.
 -   **Conventions:** Use Conventional Commits; follow `.github/PULL_REQUEST_TEMPLATE.md`.
 -   **Changelog:** Update `CHANGELOG.md` (Unreleased) for user‑visible PRs; move entries to a dated section when cutting a release.
 
Ensure completeness: ship the minimal correct implementation with tests and docs.